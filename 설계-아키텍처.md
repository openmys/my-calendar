# ProseMirror 스타일 헤드리스 캘린더 라이브러리 - 아키텍처 설계

## 1. 개요

### 1.1 목표

- **헤드리스 아키텍처**: UI와 로직 완전 분리
- **플러그인 시스템**: ProseMirror 방식의 조합 가능한 기능 확장
- **프레임워크 독립성**: 헤드리스 아키텍처로 모든 프레임워크에서 사용 가능
- **타입 안전성**: TypeScript 기반 강력한 타입 시스템
- **확장성**: 새로운 기능을 기존 코드 수정 없이 추가
- **복잡한 캘린더 지원**: 단순한 날짜 선택기부터 Google Calendar, Outlook Calendar와 같은 엔터프라이즈급 스케줄 관리 시스템까지 구축 가능
- **무한한 확장 가능성**: 프로젝트 관리, 예약 시스템, 시간표 관리, 리소스 스케줄링 등 다양한 도메인의 복잡한 요구사항 충족

### 1.2 핵심 설계 원리

- **단방향 데이터 플로우**: `User Action → Command → Transaction → State → Render`
- **불변 상태**: 모든 상태 변경은 새로운 객체 생성을 통해
- **조합성**: 독립적인 플러그인들의 조합으로 복잡한 기능 구현
- **예측 가능성**: 모든 상태 변경이 명시적 Transaction을 통해
- **시간 단위 정밀도**: 날짜뿐만 아니라 시/분/초 단위의 정밀한 시간 관리 지원
- **무한 확장성**: 플러그인 아키텍처를 통해 어떤 복잡도의 기능도 추가 가능
- **성능 최적화**: 대용량 데이터 처리를 위한 가상화, 레이지 로딩, 인크리멘탈 렌더링
- **실시간 협업**: 다중 사용자 동시 편집 및 실시간 동기화를 위한 CRDT 기반 설계 고려

## 2. 아키텍처 개요

### 2.1 레이어 구조

```
┌─────────────────────────────────────────┐
│           Framework Adapters            │  ← React 어댑터 (다른 프레임워크도 확장 가능)
├─────────────────────────────────────────┤
│              View Layer                 │  ← DOM 조작 및 이벤트 처리
├─────────────────────────────────────────┤
│            Command System               │  ← 사용자 액션을 Transaction으로 변환
├─────────────────────────────────────────┤
│           Decoration System             │  ← 선언적 UI 렌더링
├─────────────────────────────────────────┤
│            Plugin System                │  ← 비즈니스 로직 모듈화
├─────────────────────────────────────────┤
│            State System                 │  ← 불변 상태 관리
└─────────────────────────────────────────┘
```

### 2.2 데이터 플로우

```
User Interaction → Event Handler → Plugin Handler → Command → Transaction → State Update → Decoration → DOM Update
```

## 3. 핵심 시스템 설계

### 3.1 State System (상태 관리)

#### 3.1.1 PluginState 인터페이스

```typescript
abstract class PluginState<T = any> {
  constructor(public value: T) {}

  // 트랜잭션을 받아 새로운 상태 반환 (불변성)
  abstract apply(transaction: Transaction): PluginState<T>;

  // 직렬화 지원
  abstract toJSON(): any;
  static fromJSON(value: any): PluginState<any>;
}
```

#### 3.1.2 Transaction 구조

```typescript
interface Transaction {
  type: string; // 액션 타입 (예: 'SELECT_DATE', 'ADD_EVENT')
  payload: any; // 액션 데이터
  meta: Map<string, any>; // 메타데이터 (시간, 사용자 정보 등)
}
```

#### 3.1.3 전역 상태 구조

```typescript
interface CalendarState {
  currentDate: Date; // 현재 표시 중인 날짜
  viewType: ViewType; // 월간/주간/일간/타임라인/간트 등 다양한 뷰
  timeRange: TimeRange; // 시간 범위 (시작/종료 시간)
  days: CalendarDay[]; // 현재 뷰의 날짜들
  pluginStates: Map<string, PluginState>; // 각 플러그인의 상태
  // 복잡한 캘린더를 위한 추가 필드
  timezone: string; // 시간대 정보
  resources?: Resource[]; // 리소스 (회의실, 직원 등)
  filters?: FilterState; // 필터링 상태
  viewportState?: ViewportState; // 가상화를 위한 뷰포트 상태
}

// 시간 기반 일정 관리를 위한 확장 타입
interface CalendarDay {
  date: Date;
  hours?: CalendarHour[]; // 시간별 슬롯
  isToday: boolean;
  isWeekend: boolean;
  isHoliday?: boolean;
  metadata?: Map<string, any>; // 플러그인별 메타데이터
}

interface CalendarHour {
  hour: number;
  minute: number;
  slots?: TimeSlot[]; // 분 단위 슬롯
}
```

#### 3.1.4 구현 예시

```typescript
class RangePluginState extends PluginState<RangeStateValue> {
  apply(transaction: Transaction): RangePluginState {
    const newValue = { ...this.value }; // 얕은 복사

    switch (transaction.type) {
      case "SELECT_RANGE":
        newValue.selectedRange = {
          start: new Date(transaction.payload.start),
          end: new Date(transaction.payload.end),
        };
        break;

      case "CLEAR_SELECTION":
        newValue.selectedRange = null;
        break;
    }

    return new RangePluginState(newValue);
  }
}
```

### 3.2 Command System (액션 처리)

#### 3.2.1 Command 타입 정의

```typescript
type Command = (
  state: CalendarState,
  dispatch?: (transaction: Transaction) => void
) => boolean;
```

#### 3.2.2 Command 생성 패턴

```typescript
// 커맨드 팩토리 함수
const createSelectRangeCommand = (start: Date, end: Date): Command => {
  return (state, dispatch) => {
    // 1. 유효성 검사
    if (end < start) return false;

    // 2. 실행 (dispatch가 있을 때만)
    if (dispatch) {
      dispatch({
        type: "SELECT_RANGE",
        payload: { start, end },
        meta: new Map([["timestamp", Date.now()]]),
      });
    }

    return true;
  };
};
```

#### 3.2.3 Command Map 구조

```typescript
interface CommandMap {
  [commandName: string]: Command | ((...args: any[]) => Command);
}

const rangeCommands: CommandMap = {
  selectRange: (start: Date, end: Date) => createSelectRangeCommand(start, end),
  clearSelection: () => (state, dispatch) => {
    dispatch?.({ type: "CLEAR_SELECTION", payload: {}, meta: new Map() });
    return true;
  },
};
```

### 3.3 Decoration System (렌더링)

#### 3.3.1 Decoration 인터페이스

```typescript
interface Decoration {
  type: "highlight" | "overlay" | "widget";
  from: Date; // 시작 날짜
  to?: Date; // 종료 날짜 (범위용)
  spec: DecorationSpec; // 렌더링 스펙
}

interface DecorationSpec {
  class?: string; // CSS 클래스
  style?: string; // 인라인 스타일
  attributes?: Record<string, string>; // HTML 속성
  widget?: () => HTMLElement; // 위젯 생성 함수
}
```

#### 3.3.2 DecorationSet 클래스

```typescript
class DecorationSet {
  constructor(public decorations: Decoration[] = []) {}

  // 특정 날짜의 데코레이션 찾기
  find(date: Date): Decoration[] {
    return this.decorations.filter((dec) => {
      if (dec.to) {
        return date >= dec.from && date <= dec.to;
      }
      return this.isSameDay(date, dec.from);
    });
  }

  // 데코레이션 추가
  add(decoration: Decoration): DecorationSet {
    return new DecorationSet([...this.decorations, decoration]);
  }

  // 데코레이션 제거
  remove(filter: (dec: Decoration) => boolean): DecorationSet {
    return new DecorationSet(this.decorations.filter((dec) => !filter(dec)));
  }
}
```

#### 3.3.3 데코레이션 생성 함수

```typescript
const createRangeDecorations = (state: CalendarState): DecorationSet => {
  const rangeState = getRangePluginState(state);
  if (!rangeState?.selectedRange) {
    return new DecorationSet();
  }

  const { start, end } = rangeState.selectedRange;
  const decorations: Decoration[] = [];

  // 범위의 각 날짜에 데코레이션 적용
  for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
    const isStart = d.getTime() === start.getTime();
    const isEnd = d.getTime() === end.getTime();

    decorations.push({
      type: "highlight",
      from: new Date(d),
      spec: {
        class: isStart ? "range-start" : isEnd ? "range-end" : "range-middle",
      },
    });
  }

  return new DecorationSet(decorations);
};
```

### 3.4 Plugin System (기능 모듈화)

#### 3.4.1 Plugin 인터페이스

```typescript
interface PluginSpec<T = any> {
  key: string; // 플러그인 식별자
  
  // 플러그인 의존성 (복잡한 플러그인 간 상호작용 지원)
  dependencies?: string[]; // 필요한 다른 플러그인들의 key
  priority?: number; // 실행 우선순위 (낮을수록 먼저 실행)

  // 상태 관리
  state?: {
    init: () => PluginState<T>;
    apply: (transaction: Transaction, state: PluginState<T>) => PluginState<T>;
  };

  // 커맨드 제공
  commands?: () => CommandMap;

  // 데코레이션 제공
  decorations?: (state: CalendarState) => DecorationSet;

  // 이벤트 핸들러 (시간 기반 이벤트 추가)
  props?: {
    handleDateClick?: (
      date: Date,
      event: MouseEvent,
      state: CalendarState
    ) => boolean;
    handleTimeClick?: (
      datetime: Date,
      event: MouseEvent,
      state: CalendarState
    ) => boolean;
    handleKeyDown?: (event: KeyboardEvent, state: CalendarState) => boolean;
    handleDrag?: (
      dragData: DragData,
      state: CalendarState
    ) => boolean;
    handleResize?: (
      resizeData: ResizeData,
      state: CalendarState
    ) => boolean;
  };

  // 트랜잭션 후킹
  filterTransaction?: (
    transaction: Transaction,
    state: CalendarState
  ) => boolean;
  appendTransaction?: (
    transactions: Transaction[],
    oldState: CalendarState,
    newState: CalendarState
  ) => Transaction | null;
  
  // 복잡한 캘린더를 위한 추가 기능
  queries?: {
    // 플러그인이 제공하는 쿼리 메서드들
    [queryName: string]: (state: CalendarState, ...args: any[]) => any;
  };
  
  // 플러그인 간 통신을 위한 메시지 시스템
  handleMessage?: (
    message: PluginMessage,
    state: CalendarState
  ) => Transaction | null;
}

// 플러그인 간 메시지 타입
interface PluginMessage {
  from: string; // 보낸 플러그인 key
  to: string; // 받는 플러그인 key
  type: string; // 메시지 타입
  payload: any; // 메시지 데이터
}
```

#### 3.4.2 Plugin 클래스

```typescript
class Plugin<T = any> {
  constructor(public spec: PluginSpec<T>) {}

  get key(): string {
    return this.spec.key;
  }

  // 플러그인의 현재 상태 가져오기
  getState(calendarState: CalendarState): PluginState<T> | undefined {
    return calendarState.pluginStates.get(this.key) as PluginState<T>;
  }
}
```

#### 3.4.3 플러그인 구현 예시

```typescript
// Range Selection Plugin
const createRangePlugin = (options: RangeOptions = {}): Plugin<RangeState> => {
  return new Plugin({
    key: "range",

    state: {
      init: () =>
        new RangePluginState({
          selectedRange: null,
          isSelecting: false,
          options,
        }),
      apply: (transaction, state) => state.apply(transaction),
    },

    commands: () => ({
      startSelection: () => (state, dispatch) => {
        dispatch?.({ type: "START_SELECTION", payload: {}, meta: new Map() });
        return true;
      },

      selectRange: (start: Date, end: Date) => (state, dispatch) => {
        dispatch?.({
          type: "SELECT_RANGE",
          payload: { start, end },
          meta: new Map(),
        });
        return true;
      },
    }),

    decorations: createRangeDecorations,

    props: {
      handleDateClick: (date, event, state) => {
        const rangeState = this.getState(state)?.value;

        if (rangeState?.isSelecting) {
          // 범위 선택 로직
          return true;
        }

        return false;
      },
    },
  });
};
```

### 3.5 View System (DOM 관리)

#### 3.5.1 CalendarView 클래스

```typescript
class CalendarView {
  private state: CalendarState;
  private plugins: Plugin[];
  private dom: HTMLElement;
  private commandMap: CommandMap = {};

  constructor(
    element: HTMLElement,
    initialState: CalendarState,
    plugins: Plugin[]
  ) {
    this.dom = element;
    this.state = initialState;
    this.plugins = plugins;

    this.buildCommandMap();
    this.render();
    this.bindEvents();
  }

  // 트랜잭션 처리 (핵심 메서드)
  dispatch(transaction: Transaction): void {
    // 1. 트랜잭션 필터링
    const shouldProcess = this.plugins.every(
      (plugin) =>
        !plugin.spec.filterTransaction ||
        plugin.spec.filterTransaction(transaction, this.state)
    );

    if (!shouldProcess) return;

    // 2. 상태 업데이트
    const newState = this.applyTransaction(transaction);

    // 3. 추가 트랜잭션 생성
    const additionalTransactions = this.plugins
      .map((plugin) =>
        plugin.spec.appendTransaction?.([transaction], this.state, newState)
      )
      .filter(Boolean) as Transaction[];

    // 4. 상태 적용 및 렌더링
    this.state = newState;
    this.render();

    // 5. 추가 트랜잭션 처리
    additionalTransactions.forEach((tr) => this.dispatch(tr));
  }

  // 커맨드 실행
  execCommand(commandName: string, ...args: any[]): boolean {
    const command = this.commandMap[commandName];
    if (typeof command === "function") {
      return command(this.state, this.dispatch.bind(this));
    }
    return false;
  }
}
```

#### 3.5.2 상태 업데이트 로직

```typescript
private applyTransaction(transaction: Transaction): CalendarState {
    const newPluginStates = new Map<string, PluginState>();

    // 각 플러그인의 상태를 개별적으로 업데이트
    this.plugins.forEach(plugin => {
        if (plugin.spec.state) {
            const currentState = this.state.pluginStates.get(plugin.key);
            if (currentState) {
                newPluginStates.set(
                    plugin.key,
                    plugin.spec.state.apply(transaction, currentState)
                );
            }
        }
    });

    return {
        ...this.state,
        pluginStates: newPluginStates
    };
}
```

#### 3.5.3 렌더링 시스템

```typescript
private render(): void {
    // 1. 기본 캘린더 구조 렌더링
    this.renderCalendarGrid();

    // 2. 모든 플러그인의 데코레이션 수집
    const allDecorations = new DecorationSet();
    this.plugins.forEach(plugin => {
        if (plugin.spec.decorations) {
            const decorations = plugin.spec.decorations(this.state);
            decorations.decorations.forEach(dec => allDecorations.add(dec));
        }
    });

    // 3. 데코레이션 적용
    this.applyDecorations(allDecorations);
}

private applyDecorations(decorations: DecorationSet): void {
    // 기존 데코레이션 제거
    this.clearDecorations();

    // 새 데코레이션 적용
    this.state.days.forEach(day => {
        const dayElement = this.getDayElement(day.date);
        const dayDecorations = decorations.find(day.date);

        dayDecorations.forEach(decoration => {
            this.applyDecoration(dayElement, decoration);
        });
    });
}
```

## 13. 복잡한 캘린더 지원을 위한 설계 원칙

이 라이브러리는 단순한 날짜 선택기부터 Google Calendar와 같은 복잡한 스케줄 관리 시스템까지 구축할 수 있도록 설계되어야 합니다. 이를 위해 다음과 같은 설계 원칙을 따릅니다:

### 13.1 확장 가능한 데이터 모델

라이브러리의 핵심 데이터 모델은 최소한의 필수 요소만 정의하고, 플러그인을 통해 무한히 확장할 수 있어야 합니다:

- **기본 모델은 단순하게**: Date와 기본 상태만 제공
- **플러그인을 통한 확장**: 시간, 반복, 참가자, 리소스 등은 모두 플러그인으로 추가
- **타입 안전성 유지**: TypeScript의 제네릭을 활용하여 확장 시에도 타입 안전성 보장

### 13.2 성능을 고려한 아키텍처

수만 개의 일정을 처리할 수 있도록 다음과 같은 성능 최적화 전략을 기본 아키텍처에 포함:

- **레이지 로딩**: 필요한 데이터만 필요한 시점에 로드
- **가상화**: 보이는 영역의 요소만 렌더링
- **인크리멘탈 업데이트**: 변경된 부분만 재렌더링
- **메모이제이션**: 계산 비용이 높은 연산 결과 캐싱

### 13.3 플러그인 간 협업 메커니즘

복잡한 기능은 여러 플러그인의 조합으로 구현되므로, 플러그인 간 협업이 원활해야 합니다:

- **메시지 시스템**: 플러그인 간 통신을 위한 표준화된 메시지 전달
- **의존성 관리**: 플러그인이 다른 플러그인을 필요로 할 때 자동 로드
- **우선순위 시스템**: 이벤트 처리 순서를 명확히 정의
- **쿼리 시스템**: 플러그인이 다른 플러그인의 상태를 조회할 수 있는 인터페이스

### 13.4 시간 복잡도를 고려한 설계

스케줄 캘린더와 같은 복잡한 애플리케이션은 시간 기반 작업이 핵심이므로:

- **시간 정밀도 지원**: 날짜뿐만 아니라 시/분/초 단위까지 확장 가능
- **시간대 처리**: 플러그인을 통해 다양한 시간대 지원
- **반복 패턴**: 복잡한 반복 규칙을 처리할 수 있는 확장 포인트 제공

### 13.5 실시간 협업을 위한 준비

다중 사용자 환경을 고려한 설계:

- **트랜잭션 기반 상태 관리**: 모든 변경사항을 추적 가능
- **충돌 해결 메커니즘**: 동시 편집 시 충돌을 해결할 수 있는 구조
- **이벤트 스트림**: 외부 시스템과의 실시간 동기화를 위한 이벤트 시스템

### 13.6 다양한 뷰 모드 지원

복잡한 캘린더는 다양한 방식으로 데이터를 표현해야 하므로:

- **뷰 독립적인 데이터 모델**: 데이터와 표현을 완전히 분리
- **커스텀 뷰 생성**: 개발자가 새로운 뷰를 쉽게 추가할 수 있는 구조
- **뷰 간 전환**: 같은 데이터를 다른 뷰에서 매끄럽게 표현

### 13.7 개발자 경험 (DX) 최적화

복잡한 기능을 구현하더라도 개발자가 쉽게 사용할 수 있도록:

- **점진적 복잡도**: 간단한 사용은 간단하게, 복잡한 사용은 가능하게
- **명확한 API**: 직관적이고 일관된 API 설계
- **풍부한 타입 정보**: IDE의 자동완성과 타입 체크 활용
- **디버깅 지원**: 상태 변화를 추적하고 디버깅할 수 있는 도구

이러한 설계 원칙을 통해 개발자들은 다음과 같은 다양한 복잡도의 애플리케이션을 구축할 수 있습니다:

- **단순 날짜 선택기**: 기본 플러그인만 사용
- **예약 시스템**: 시간 슬롯과 가용성 플러그인 조합
- **프로젝트 관리 도구**: 간트 차트와 리소스 플러그인 조합
- **엔터프라이즈 스케줄러**: 모든 고급 플러그인을 조합하여 Google Calendar 수준의 기능 구현

핵심은 라이브러리가 이 모든 사용 사례를 직접 구현하는 것이 아니라, 개발자가 필요에 따라 이러한 기능을 구현할 수 있는 **견고한 기반**을 제공하는 것입니다.

## 14. 보안 및 에러 처리

### 14.1 보안 아키텍처

#### 14.1.1 입력 검증 및 Sanitization

모든 사용자 입력과 외부 데이터는 엄격한 검증을 거쳐야 합니다:

```typescript
interface InputValidator {
  validateDate(date: unknown): Date | ValidationError;
  validateTimeRange(range: unknown): TimeRange | ValidationError;
  validateEventData(data: unknown): EventData | ValidationError;
}

class SecurityPlugin extends Plugin<SecurityState> {
  spec = {
    state: {
      init: () => new SecurityState({}),
      apply: (tr: Transaction, state: SecurityState) => {
        // 모든 트랜잭션의 페이로드를 검증
        if (!this.validateTransaction(tr)) {
          throw new SecurityError('Invalid transaction payload');
        }
        return state;
      }
    }
  };

  private validateTransaction(tr: Transaction): boolean {
    // XSS 방지를 위한 HTML 태그 검증
    if (tr.type === 'ADD_EVENT' && tr.payload.description) {
      return this.sanitizeHTML(tr.payload.description);
    }
    return true;
  }
}
```

#### 14.1.2 XSS 방지

데코레이션 시스템에서 HTML 렌더링 시 XSS 공격을 방지:

```typescript
class SecureDecoration extends Decoration {
  constructor(
    public element: string,
    public attributes: Record<string, string>,
    public content?: string
  ) {
    super();
    // 모든 속성값과 콘텐츠를 sanitize
    this.attributes = this.sanitizeAttributes(attributes);
    this.content = content ? this.sanitizeContent(content) : undefined;
  }

  private sanitizeAttributes(attrs: Record<string, string>): Record<string, string> {
    const sanitized: Record<string, string> = {};
    for (const [key, value] of Object.entries(attrs)) {
      // 위험한 속성 필터링
      if (!key.startsWith('on') && key !== 'javascript:') {
        sanitized[key] = this.escapeHTML(value);
      }
    }
    return sanitized;
  }
}
```

#### 14.1.3 플러그인 샌드박싱

서드파티 플러그인의 안전한 실행을 위한 격리:

```typescript
interface PluginSandbox {
  allowedAPIs: string[];
  memoryLimit: number;
  timeoutMs: number;
}

class PluginManager {
  loadPlugin(plugin: Plugin, sandbox: PluginSandbox): SafePlugin {
    return new Proxy(plugin, {
      get(target, prop) {
        if (!sandbox.allowedAPIs.includes(prop as string)) {
          throw new SecurityError(`API ${String(prop)} not allowed`);
        }
        return target[prop as keyof Plugin];
      }
    });
  }
}
```

### 14.2 에러 처리 및 복구

#### 14.2.1 Transaction 실패 처리

Transaction 실행 중 에러 발생 시 롤백 메커니즘:

```typescript
class TransactionManager {
  private applyTransaction(tr: Transaction, state: CalendarState): CalendarState {
    const checkpoint = this.createCheckpoint(state);
    
    try {
      // 각 플러그인에서 transaction 적용
      const newPluginStates = new Map<string, PluginState>();
      
      for (const [pluginId, plugin] of this.plugins) {
        const currentState = state.pluginStates.get(pluginId);
        if (currentState && plugin.spec.state) {
          const newState = plugin.spec.state.apply(tr, currentState);
          newPluginStates.set(pluginId, newState);
        }
      }
      
      return {
        ...state,
        pluginStates: newPluginStates
      };
      
    } catch (error) {
      // 에러 발생 시 체크포인트로 롤백
      this.rollbackToCheckpoint(checkpoint);
      throw new TransactionError(`Transaction failed: ${error.message}`, {
        transaction: tr,
        originalError: error
      });
    }
  }
}
```

#### 14.2.2 플러그인 로딩 실패 처리

```typescript
class PluginLoader {
  async loadPlugin(pluginDef: PluginDefinition): Promise<Plugin | null> {
    try {
      const plugin = await import(pluginDef.module);
      
      // 플러그인 검증
      if (!this.validatePlugin(plugin)) {
        throw new PluginError('Invalid plugin structure');
      }
      
      return plugin;
      
    } catch (error) {
      console.warn(`Failed to load plugin ${pluginDef.name}:`, error);
      
      // 크리티컬 플러그인이 아닌 경우 무시하고 계속 진행
      if (!pluginDef.critical) {
        return null;
      }
      
      // 크리티컬 플러그인 로딩 실패 시 fallback 제공
      return this.getFallbackPlugin(pluginDef.name);
    }
  }
}
```

#### 14.2.3 상태 불일치 복구

```typescript
class StateValidator {
  validateState(state: CalendarState): ValidationResult {
    const errors: StateError[] = [];
    
    // 날짜 일관성 검증
    if (state.currentDate > state.timeRange.end) {
      errors.push(new StateError('Current date outside time range'));
    }
    
    // 플러그인 상태 간 일관성 검증
    for (const [pluginId, pluginState] of state.pluginStates) {
      const validation = this.validatePluginState(pluginId, pluginState, state);
      if (!validation.valid) {
        errors.push(...validation.errors);
      }
    }
    
    return { valid: errors.length === 0, errors };
  }

  repairState(state: CalendarState): CalendarState {
    const validation = this.validateState(state);
    if (validation.valid) return state;
    
    let repairedState = { ...state };
    
    for (const error of validation.errors) {
      repairedState = this.applyRepair(repairedState, error);
    }
    
    return repairedState;
  }
}
```

### 14.3 에러 타입 정의

```typescript
// 기본 에러 클래스
abstract class CalendarError extends Error {
  constructor(
    message: string,
    public code: string,
    public context?: any
  ) {
    super(message);
    this.name = this.constructor.name;
  }
}

// 구체적인 에러 타입들
class ValidationError extends CalendarError {
  constructor(message: string, public field: string, public value: any) {
    super(message, 'VALIDATION_ERROR', { field, value });
  }
}

class TransactionError extends CalendarError {
  constructor(message: string, context: any) {
    super(message, 'TRANSACTION_ERROR', context);
  }
}

class PluginError extends CalendarError {
  constructor(message: string, public pluginId?: string) {
    super(message, 'PLUGIN_ERROR', { pluginId });
  }
}

class SecurityError extends CalendarError {
  constructor(message: string) {
    super(message, 'SECURITY_ERROR');
  }
}
```

### 14.4 에러 보고 및 모니터링

```typescript
interface ErrorReporter {
  report(error: CalendarError): void;
  setErrorBoundary(handler: (error: CalendarError) => void): void;
}

class DefaultErrorReporter implements ErrorReporter {
  private handlers: ((error: CalendarError) => void)[] = [];
  
  report(error: CalendarError): void {
    // 개발 환경에서는 콘솔에 자세한 정보 출력
    if (process.env.NODE_ENV === 'development') {
      console.group(`Calendar Error: ${error.code}`);
      console.error(error.message);
      console.log('Context:', error.context);
      console.trace();
      console.groupEnd();
    }
    
    // 프로덕션 환경에서는 에러 추적 서비스로 전송
    if (process.env.NODE_ENV === 'production') {
      this.sendToErrorTracking(error);
    }
    
    // 등록된 핸들러들에게 알림
    this.handlers.forEach(handler => handler(error));
  }
  
  setErrorBoundary(handler: (error: CalendarError) => void): void {
    this.handlers.push(handler);
  }
}
```

## 15. 접근성(Accessibility) 지원

### 15.1 접근성 아키텍처

캘린더는 시각적 정보가 많은 컴포넌트이므로, 다양한 사용자가 접근할 수 있도록 포괄적인 접근성 지원이 필요합니다.

#### 15.1.1 ARIA 지원 시스템

```typescript
interface AccessibilityState {
  focusedDate: Date | null;
  announcement: string | null;
  navigationMode: 'grid' | 'list' | 'timeline';
  describedBy: Map<string, string>; // 요소 ID와 설명 매핑
}

class AccessibilityPlugin extends Plugin<AccessibilityState> {
  spec = {
    state: {
      init: () => new AccessibilityState({
        focusedDate: null,
        announcement: null,
        navigationMode: 'grid',
        describedBy: new Map()
      }),
      apply: (tr: Transaction, state: AccessibilityState) => {
        switch (tr.type) {
          case 'FOCUS_DATE':
            return new AccessibilityState({
              ...state.value,
              focusedDate: tr.payload.date,
              announcement: this.createDateAnnouncement(tr.payload.date)
            });
          case 'NAVIGATE_CALENDAR':
            return new AccessibilityState({
              ...state.value,
              navigationMode: tr.payload.mode
            });
        }
        return state;
      }
    },
    
    decorations: (state: CalendarState) => {
      const a11yState = this.getState(state);
      const decorations: Decoration[] = [];
      
      // 캘린더 그리드에 ARIA 속성 추가
      decorations.push(new AriaDecoration('div', {
        role: 'grid',
        'aria-label': '캘린더',
        'aria-activedescendant': a11yState.focusedDate ? 
          this.getDateCellId(a11yState.focusedDate) : undefined
      }));
      
      return decorations;
    }
  };
}
```

#### 15.1.2 키보드 네비게이션

```typescript
class KeyboardNavigationPlugin extends Plugin<KeyboardState> {
  spec = {
    keymap: {
      'ArrowRight': (state: CalendarState) => {
        const currentFocused = this.getFocusedDate(state);
        const nextDate = addDays(currentFocused, 1);
        return this.createFocusTransaction(nextDate);
      },
      
      'ArrowLeft': (state: CalendarState) => {
        const currentFocused = this.getFocusedDate(state);
        const prevDate = subDays(currentFocused, 1);
        return this.createFocusTransaction(prevDate);
      },
      
      'ArrowDown': (state: CalendarState) => {
        const currentFocused = this.getFocusedDate(state);
        const nextWeek = addWeeks(currentFocused, 1);
        return this.createFocusTransaction(nextWeek);
      },
      
      'ArrowUp': (state: CalendarState) => {
        const currentFocused = this.getFocusedDate(state);
        const prevWeek = subWeeks(currentFocused, 1);
        return this.createFocusTransaction(prevWeek);
      },
      
      'Enter': (state: CalendarState) => {
        const focusedDate = this.getFocusedDate(state);
        return this.createSelectTransaction(focusedDate);
      },
      
      'Space': (state: CalendarState) => {
        const focusedDate = this.getFocusedDate(state);
        return this.createSelectTransaction(focusedDate);
      },
      
      'Home': (state: CalendarState) => {
        const currentFocused = this.getFocusedDate(state);
        const startOfWeek = startOfWeek(currentFocused);
        return this.createFocusTransaction(startOfWeek);
      },
      
      'End': (state: CalendarState) => {
        const currentFocused = this.getFocusedDate(state);
        const endOfWeek = endOfWeek(currentFocused);
        return this.createFocusTransaction(endOfWeek);
      },
      
      'PageUp': (state: CalendarState) => {
        const currentFocused = this.getFocusedDate(state);
        const prevMonth = subMonths(currentFocused, 1);
        return this.createFocusTransaction(prevMonth);
      },
      
      'PageDown': (state: CalendarState) => {
        const currentFocused = this.getFocusedDate(state);
        const nextMonth = addMonths(currentFocused, 1);
        return this.createFocusTransaction(nextMonth);
      }
    }
  };
}
```

#### 15.1.3 스크린 리더 지원

```typescript
class ScreenReaderPlugin extends Plugin<ScreenReaderState> {
  spec = {
    decorations: (state: CalendarState) => {
      const decorations: Decoration[] = [];
      
      // 각 날짜 셀에 적절한 레이블 추가
      for (const day of state.days) {
        const events = this.getEventsForDate(day.date, state);
        const ariaLabel = this.createDateLabel(day.date, events);
        
        decorations.push(new AriaDecoration('td', {
          role: 'gridcell',
          'aria-label': ariaLabel,
          'aria-selected': this.isSelected(day.date, state) ? 'true' : 'false',
          tabindex: this.isFocused(day.date, state) ? '0' : '-1'
        }));
      }
      
      return decorations;
    }
  };
  
  private createDateLabel(date: Date, events: Event[]): string {
    const dayName = format(date, 'EEEE', { locale: this.locale });
    const dateStr = format(date, 'MMMM d, yyyy', { locale: this.locale });
    
    let label = `${dayName}, ${dateStr}`;
    
    if (events.length > 0) {
      label += `, ${events.length}개의 일정`;
      if (events.length <= 3) {
        const eventTitles = events.map(e => e.title).join(', ');
        label += `: ${eventTitles}`;
      }
    }
    
    return label;
  }
}
```

### 15.2 고대비 모드 지원

```typescript
class HighContrastPlugin extends Plugin<HighContrastState> {
  spec = {
    decorations: (state: CalendarState) => {
      if (!this.isHighContrastMode()) return [];
      
      const decorations: Decoration[] = [];
      
      // 고대비 모드에서 명확한 경계선과 색상 사용
      decorations.push(new StyleDecoration('calendar-container', {
        '--calendar-border': '2px solid black',
        '--calendar-selected-bg': 'black',
        '--calendar-selected-color': 'white',
        '--calendar-focus-outline': '3px solid blue'
      }));
      
      return decorations;
    }
  };
  
  private isHighContrastMode(): boolean {
    return window.matchMedia('(prefers-contrast: high)').matches;
  }
}
```

### 15.3 모션 감소 지원

```typescript
class ReducedMotionPlugin extends Plugin<MotionState> {
  spec = {
    decorations: (state: CalendarState) => {
      if (!this.prefersReducedMotion()) return [];
      
      return [
        new StyleDecoration('calendar-container', {
          '--calendar-transition-duration': '0ms',
          '--calendar-animation-duration': '0ms'
        })
      ];
    }
  };
  
  private prefersReducedMotion(): boolean {
    return window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  }
}
```

### 15.4 다양한 입력 방식 지원

```typescript
class InputMethodPlugin extends Plugin<InputMethodState> {
  spec = {
    props: {
      // 터치 입력 지원
      handleTouchStart: (view: CalendarView, event: TouchEvent) => {
        const target = event.target as HTMLElement;
        const date = this.getDateFromElement(target);
        if (date) {
          return this.createSelectTransaction(date);
        }
        return false;
      },
      
      // 음성 명령 지원 (Web Speech API)
      handleSpeechCommand: (view: CalendarView, command: string) => {
        const parsed = this.parseDateCommand(command);
        if (parsed) {
          return this.createNavigateTransaction(parsed.date);
        }
        return false;
      }
    }
  };
  
  private parseDateCommand(command: string): { date: Date } | null {
    // "다음 주 화요일로 이동", "12월 25일 선택" 등의 명령 파싱
    const patterns = [
      /다음\s*주\s*([월화수목금토일]요일)/,
      /(\d+)월\s*(\d+)일/,
      /내일|어제|오늘/
    ];
    
    for (const pattern of patterns) {
      const match = command.match(pattern);
      if (match) {
        return { date: this.parseMatchToDate(match) };
      }
    }
    
    return null;
  }
}
```

### 15.5 접근성 검증 및 테스트

```typescript
class AccessibilityValidator {
  validateCalendar(state: CalendarState): AccessibilityReport {
    const issues: AccessibilityIssue[] = [];
    
    // ARIA 라벨 검증
    if (!this.hasAriaLabel(state)) {
      issues.push({
        type: 'missing-aria-label',
        severity: 'error',
        message: '캘린더에 aria-label이 없습니다'
      });
    }
    
    // 키보드 네비게이션 검증
    if (!this.hasKeyboardSupport(state)) {
      issues.push({
        type: 'missing-keyboard-support',
        severity: 'error',
        message: '키보드 네비게이션이 지원되지 않습니다'
      });
    }
    
    // 색상 대비 검증
    const contrastIssues = this.checkColorContrast(state);
    issues.push(...contrastIssues);
    
    return {
      valid: issues.filter(i => i.severity === 'error').length === 0,
      issues
    };
  }
  
  private checkColorContrast(state: CalendarState): AccessibilityIssue[] {
    // 색상 대비 비율 계산 (WCAG 2.1 기준)
    const issues: AccessibilityIssue[] = [];
    
    const elements = this.getColoredElements(state);
    for (const element of elements) {
      const ratio = this.calculateContrastRatio(
        element.backgroundColor,
        element.textColor
      );
      
      if (ratio < 4.5) { // WCAG AA 기준
        issues.push({
          type: 'low-contrast',
          severity: 'warning',
          message: `색상 대비가 낮습니다: ${ratio.toFixed(2)}:1`
        });
      }
    }
    
    return issues;
  }
}
```

### 15.6 다국어 접근성 지원

```typescript
interface AccessibilityMessages {
  dateSelected: (date: Date) => string;
  monthChanged: (month: string) => string;
  eventAnnouncement: (event: Event) => string;
  navigationHelp: () => string;
}

class LocalizedAccessibilityPlugin extends Plugin<LocalizedA11yState> {
  constructor(private messages: AccessibilityMessages) {
    super();
  }
  
  private announceToScreenReader(message: string): void {
    // 스크린 리더에 즉시 알림
    const announcement = document.createElement('div');
    announcement.setAttribute('aria-live', 'assertive');
    announcement.setAttribute('aria-atomic', 'true');
    announcement.className = 'sr-only'; // 시각적으로 숨김
    announcement.textContent = message;
    
    document.body.appendChild(announcement);
    
    // 메시지 읽힌 후 제거
    setTimeout(() => {
      document.body.removeChild(announcement);
    }, 1000);
  }
}
```

## 16. 국제화(i18n) 지원

### 16.1 다국어 아키텍처

캘린더는 전 세계에서 사용되므로 다양한 언어와 지역별 관습을 지원해야 합니다.

#### 16.1.1 로케일 기반 상태 관리

```typescript
interface LocaleState {
  locale: string; // 'ko-KR', 'en-US', 'ja-JP' 등
  dateFormat: DateFormat;
  timeFormat: TimeFormat;
  weekStartsOn: WeekDay; // 0: 일요일, 1: 월요일
  rtl: boolean; // Right-to-Left 언어 지원
  timezone: string;
}

class LocalizationPlugin extends Plugin<LocaleState> {
  spec = {
    state: {
      init: (config: LocaleConfig) => new LocaleState({
        locale: config.locale || this.detectLocale(),
        dateFormat: this.getDateFormat(config.locale),
        timeFormat: this.getTimeFormat(config.locale),
        weekStartsOn: this.getWeekStart(config.locale),
        rtl: this.isRTL(config.locale),
        timezone: config.timezone || Intl.DateTimeFormat().resolvedOptions().timeZone
      }),
      apply: (tr: Transaction, state: LocaleState) => {
        if (tr.type === 'CHANGE_LOCALE') {
          return new LocaleState({
            ...state.value,
            locale: tr.payload.locale,
            rtl: this.isRTL(tr.payload.locale)
          });
        }
        return state;
      }
    }
  };
}
```

#### 16.1.2 다국어 메시지 시스템

```typescript
interface LocalizedMessages {
  // 일반적인 UI 메시지
  today: string;
  nextMonth: string;
  previousMonth: string;
  selectDate: string;
  
  // 날짜 관련
  weekdays: [string, string, string, string, string, string, string];
  weekdaysShort: [string, string, string, string, string, string, string];
  months: [string, string, string, string, string, string, string, string, string, string, string, string];
  monthsShort: [string, string, string, string, string, string, string, string, string, string, string, string];
  
  // 접근성 메시지
  dateSelected: (date: Date) => string;
  monthChanged: (month: string) => string;
  
  // 이벤트 관련
  event: string;
  events: string;
  noEvents: string;
  addEvent: string;
  
  // 시간 관련
  am: string;
  pm: string;
  hour: string;
  minute: string;
}

class MessageProvider {
  private messages: Map<string, LocalizedMessages> = new Map();
  
  register(locale: string, messages: LocalizedMessages): void {
    this.messages.set(locale, messages);
  }
  
  get(locale: string): LocalizedMessages {
    return this.messages.get(locale) || this.messages.get('en')!;
  }
  
  formatMessage(locale: string, key: keyof LocalizedMessages, ...args: any[]): string {
    const messages = this.get(locale);
    const message = messages[key];
    
    if (typeof message === 'function') {
      return message(...args);
    }
    
    return message as string;
  }
}
```

### 16.2 날짜 형식 지역화

#### 16.2.1 유연한 날짜 포매팅

```typescript
class DateFormatter {
  private formatters: Map<string, Intl.DateTimeFormat> = new Map();
  
  format(date: Date, locale: string, options?: Intl.DateTimeFormatOptions): string {
    const key = `${locale}-${JSON.stringify(options)}`;
    
    if (!this.formatters.has(key)) {
      this.formatters.set(key, new Intl.DateTimeFormat(locale, options));
    }
    
    return this.formatters.get(key)!.format(date);
  }
  
  formatRange(startDate: Date, endDate: Date, locale: string): string {
    const formatter = new Intl.DateTimeFormat(locale, {
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    });
    
    return formatter.formatRange(startDate, endDate);
  }
  
  getLocalizedPattern(locale: string, pattern: 'date' | 'time' | 'datetime'): string {
    // 각 로케일별 날짜/시간 패턴 반환
    const patterns = {
      'ko-KR': {
        date: 'YYYY년 M월 D일',
        time: 'A h:mm',
        datetime: 'YYYY년 M월 D일 A h:mm'
      },
      'en-US': {
        date: 'M/D/YYYY',
        time: 'h:mm A',
        datetime: 'M/D/YYYY h:mm A'
      },
      'ja-JP': {
        date: 'YYYY年M月D日',
        time: 'Ah:mm',
        datetime: 'YYYY年M月D日 Ah:mm'
      }
    };
    
    return patterns[locale]?.[pattern] || patterns['en-US'][pattern];
  }
}
```

#### 16.2.2 캘린더 주 시작일 처리

```typescript
class WeekCalculator {
  getWeekdays(locale: string): Date[] {
    const localeState = this.getLocaleState();
    const weekStartsOn = localeState.weekStartsOn;
    
    const today = new Date();
    const startOfWeek = new Date(today);
    const day = today.getDay();
    const diff = day >= weekStartsOn ? day - weekStartsOn : 6 - weekStartsOn + day + 1;
    
    startOfWeek.setDate(today.getDate() - diff);
    
    return Array.from({ length: 7 }, (_, i) => {
      const date = new Date(startOfWeek);
      date.setDate(startOfWeek.getDate() + i);
      return date;
    });
  }
  
  getWeekdayNames(locale: string, format: 'long' | 'short' | 'narrow' = 'short'): string[] {
    const weekdays = this.getWeekdays(locale);
    
    return weekdays.map(date => 
      new Intl.DateTimeFormat(locale, { weekday: format }).format(date)
    );
  }
}
```

### 16.3 RTL(Right-to-Left) 언어 지원

#### 16.3.1 RTL 레이아웃 처리

```typescript
class RTLPlugin extends Plugin<RTLState> {
  spec = {
    decorations: (state: CalendarState) => {
      const localeState = this.getLocaleState(state);
      if (!localeState.rtl) return [];
      
      return [
        new StyleDecoration('calendar-container', {
          direction: 'rtl',
          '--calendar-text-align': 'right'
        }),
        
        // 네비게이션 버튼 순서 변경
        new ClassDecoration('calendar-nav', 'rtl-nav'),
        
        // 주 헤더 순서 변경
        new ClassDecoration('calendar-week-header', 'rtl-week-header')
      ];
    },
    
    keymap: {
      // RTL에서는 키보드 네비게이션 방향이 반대
      'ArrowRight': (state: CalendarState) => {
        const localeState = this.getLocaleState(state);
        if (localeState.rtl) {
          return this.moveFocusPrevious(state);
        }
        return this.moveFocusNext(state);
      },
      
      'ArrowLeft': (state: CalendarState) => {
        const localeState = this.getLocaleState(state);
        if (localeState.rtl) {
          return this.moveFocusNext(state);
        }
        return this.moveFocusPrevious(state);
      }
    }
  };
}
```

### 16.4 시간대 처리

#### 16.4.1 다중 시간대 지원

```typescript
class TimezonePlugin extends Plugin<TimezoneState> {
  spec = {
    state: {
      init: (config: TimezoneConfig) => new TimezoneState({
        primary: config.primary || Intl.DateTimeFormat().resolvedOptions().timeZone,
        additional: config.additional || [],
        displayFormat: config.displayFormat || '24h'
      }),
      apply: (tr: Transaction, state: TimezoneState) => {
        switch (tr.type) {
          case 'CHANGE_TIMEZONE':
            return new TimezoneState({
              ...state.value,
              primary: tr.payload.timezone
            });
          case 'ADD_TIMEZONE':
            return new TimezoneState({
              ...state.value,
              additional: [...state.value.additional, tr.payload.timezone]
            });
        }
        return state;
      }
    }
  };
  
  convertToTimezone(date: Date, fromTz: string, toTz: string): Date {
    const utc = new Date(date.toLocaleString('en-US', { timeZone: 'UTC' }));
    return new Date(utc.toLocaleString('en-US', { timeZone: toTz }));
  }
  
  formatInTimezone(date: Date, timezone: string, locale: string): string {
    return new Intl.DateTimeFormat(locale, {
      timeZone: timezone,
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    }).format(date);
  }
}
```

### 16.5 숫자 및 통화 지역화

#### 16.5.1 숫자 형식 처리

```typescript
class NumberFormatter {
  formatNumber(value: number, locale: string, options?: Intl.NumberFormatOptions): string {
    return new Intl.NumberFormat(locale, options).format(value);
  }
  
  formatCurrency(amount: number, currency: string, locale: string): string {
    return new Intl.NumberFormat(locale, {
      style: 'currency',
      currency: currency
    }).format(amount);
  }
  
  formatDuration(minutes: number, locale: string): string {
    const hours = Math.floor(minutes / 60);
    const mins = minutes % 60;
    
    const rtf = new Intl.RelativeTimeFormat(locale, { numeric: 'auto' });
    
    if (hours > 0) {
      return `${hours}시간 ${mins}분`;
    }
    return `${mins}분`;
  }
}
```

### 16.6 달력 시스템 지원

#### 16.6.1 다양한 달력 시스템

```typescript
interface CalendarSystem {
  name: string;
  toGregorian(date: CalendarDate): Date;
  fromGregorian(date: Date): CalendarDate;
  getMonthNames(locale: string): string[];
  getWeekdayNames(locale: string): string[];
}

class CalendarSystemPlugin extends Plugin<CalendarSystemState> {
  private systems: Map<string, CalendarSystem> = new Map();
  
  constructor() {
    super();
    this.registerSystem('gregorian', new GregorianCalendar());
    this.registerSystem('hijri', new HijriCalendar());
    this.registerSystem('hebrew', new HebrewCalendar());
    this.registerSystem('persian', new PersianCalendar());
  }
  
  registerSystem(name: string, system: CalendarSystem): void {
    this.systems.set(name, system);
  }
  
  convertDate(date: Date, fromSystem: string, toSystem: string): CalendarDate {
    const from = this.systems.get(fromSystem);
    const to = this.systems.get(toSystem);
    
    if (!from || !to) {
      throw new Error(`Calendar system not found`);
    }
    
    const calendarDate = from.fromGregorian(date);
    return to.fromGregorian(from.toGregorian(calendarDate));
  }
}
```

### 16.7 동적 로케일 변경

#### 16.7.1 실시간 언어 전환

```typescript
class LocaleSwitcher {
  async changeLocale(newLocale: string, view: CalendarView): Promise<void> {
    // 1. 메시지 번들 로드
    const messages = await this.loadMessages(newLocale);
    
    // 2. 로케일 상태 업데이트
    const transaction = {
      type: 'CHANGE_LOCALE',
      payload: { locale: newLocale },
      meta: new Map([['timestamp', Date.now()]])
    };
    
    // 3. 뷰 업데이트
    view.dispatch(transaction);
    
    // 4. DOM 속성 업데이트
    document.documentElement.lang = newLocale;
    document.documentElement.dir = this.isRTL(newLocale) ? 'rtl' : 'ltr';
  }
  
  private async loadMessages(locale: string): Promise<LocalizedMessages> {
    try {
      const messages = await import(`../locales/${locale}.json`);
      return messages.default;
    } catch (error) {
      console.warn(`Failed to load locale ${locale}, falling back to English`);
      return await import('../locales/en.json');
    }
  }
}
```

이 설계문서를 기반으로 다른 개발자나 LLM이 동일한 아키텍처의 헤드리스 캘린더 라이브러리를 구현할 수 있습니다. 핵심은 ProseMirror의 성공적인 패턴을 캘린더 도메인에 적용하면서도, 복잡한 스케줄 관리 시스템의 요구사항을 충족할 수 있는 확장성을 제공하는 것입니다.