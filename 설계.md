# ProseMirror 스타일 헤드리스 캘린더 라이브러리 설계문서

이 문서는 ProseMirror의 성공적인 아키텍처 패턴을 캘린더 도메인에 적용한 헤드리스 캘린더 라이브러리의 설계 문서입니다.

## 📋 목차

### 📖 설계 문서 구조

이 설계 문서는 목적에 따라 3개의 파일로 구성되어 있습니다:

1. **[설계-아키텍처.md](./설계-아키텍처.md)** - 핵심 아키텍처 설계
   - 라이브러리의 핵심 철학과 설계 원리
   - 시스템 아키텍처와 데이터 플로우
   - 플러그인 시스템 설계
   - 복잡한 캘린더 지원을 위한 설계 원칙

2. **[설계-개발가이드.md](./설계-개발가이드.md)** - 개발자 가이드
   - React 어댑터 사용법
   - 플러그인 개발 가이드
   - 내장 플러그인 소개
   - 사용 예시 및 마이그레이션 가이드
   - 확장 가이드

3. **[설계-프로젝트관리.md](./설계-프로젝트관리.md)** - 프로젝트 관리
   - 테스트 전략 및 성능 최적화
   - 모노레포 구조 및 빌드 전략
   - GitHub Actions를 통한 자동 배포

### 🎯 프로젝트 개요

**목표**: ProseMirror처럼 강력하고 확장 가능한 헤드리스 캘린더 라이브러리 구축

**핵심 특징**:
- **헤드리스 아키텍처**: UI와 로직 완전 분리
- **플러그인 시스템**: ProseMirror 방식의 조합 가능한 기능 확장
- **프레임워크 독립성**: 헤드리스 아키텍처로 모든 프레임워크에서 사용 가능
- **타입 안전성**: TypeScript 기반 강력한 타입 시스템
- **확장성**: 새로운 기능을 기존 코드 수정 없이 추가
- **복잡한 캘린더 지원**: 단순한 날짜 선택기부터 Google Calendar와 같은 엔터프라이즈급 스케줄 관리 시스템까지

**설계 원리**:
- **단방향 데이터 플로우**: `User Action → Command → Transaction → State → Render`
- **불변 상태**: 모든 상태 변경은 새로운 객체 생성을 통해
- **조합성**: 독립적인 플러그인들의 조합으로 복잡한 기능 구현
- **예측 가능성**: 모든 상태 변경이 명시적 Transaction을 통해

### 💡 빠른 시작

각 문서의 주요 내용을 간략히 요약하면:

#### 🏗️ 아키텍처 ([상세 보기](./설계-아키텍처.md))
- **State System**: 불변 상태 관리와 Transaction 기반 업데이트
- **Command System**: 사용자 액션을 구조화된 명령으로 변환
- **Plugin System**: 모듈화된 기능 확장을 위한 플러그인 아키텍처
- **Decoration System**: 선언적 UI 렌더링 시스템

#### 👨‍💻 개발 가이드 ([상세 보기](./설계-개발가이드.md))
- **React 통합**: useCalendar Hook과 컴포넌트 사용법
- **플러그인 개발**: 커스텀 플러그인 개발 패턴과 예시
- **내장 플러그인**: Range Selection, Event Management 등
- **마이그레이션**: 기존 캘린더 라이브러리에서 이전하는 방법

#### 🛠️ 프로젝트 관리 ([상세 보기](./설계-프로젝트관리.md))
- **테스트 전략**: 단위/통합/E2E 테스트와 성능 테스트
- **성능 최적화**: 메모이제이션, 가상화, 레이지 로딩
- **빌드 시스템**: Turborepo + pnpm workspace 모노레포
- **자동 배포**: GitHub Actions를 통한 NPM 퍼블리싱

### 🚀 사용 예시

```typescript
// 기본 사용법
const plugins = [
  createRangePlugin({ maxRange: 7 }),
  createEventPlugin({ allowOverlap: false }),
];

// React에서 사용
function MyCalendar() {
  const { state, execCommand } = useCalendar({ plugins });
  
  return (
    <Calendar
      plugins={plugins}
      onDateClick={(date) => console.log('Selected:', date)}
    />
  );
}
```

### 📚 API 레퍼런스 및 문서

- **[API 문서](https://my-calendar.docs.dev/api)** - TypeDoc으로 자동 생성되는 상세 API 문서
- **[플러그인 개발 가이드](https://my-calendar.docs.dev/plugins)** - 커스텀 플러그인 개발 방법
- **[예제 모음](https://my-calendar.docs.dev/examples)** - 다양한 사용 사례별 구현 예시
- **[마이그레이션 가이드](https://my-calendar.docs.dev/migration)** - 다른 캘린더 라이브러리에서 이전하는 방법
- **[트러블슈팅](https://my-calendar.docs.dev/troubleshooting)** - 자주 발생하는 문제와 해결책

### 🤝 기여 및 커뮤니티

이 프로젝트는 오픈소스로 운영되며, 커뮤니티의 기여를 환영합니다:

- **[기여 가이드](./CONTRIBUTING.md)** - 프로젝트 기여 방법과 규칙
- **[이슈 트래커](https://github.com/my-calendar/core/issues)** - 버그 리포트 및 기능 요청
- **[토론 포럼](https://github.com/my-calendar/core/discussions)** - 질문과 아이디어 공유
- **[코드 리뷰 가이드라인](./CODE_REVIEW.md)** - Pull Request 리뷰 프로세스

**기여 방법:**
1. 이슈 확인 및 논의
2. Fork & 브랜치 생성
3. 개발 및 테스트 (100% 커버리지 필수)
4. Pull Request 생성
5. 코드 리뷰 및 머지

### 📦 설치 및 시작하기

```bash
# npm
npm install @openmys/my-calendar

# yarn  
yarn add @openmys/my-calendar

# pnpm
pnpm add @openmys/my-calendar
```

**빠른 시작:**

```typescript
import { createCalendar, createRangePlugin } from '@openmys/my-calendar';

const calendar = createCalendar({
  plugins: [createRangePlugin()]
});
```

---

> 💡 **참고**: 이 설계는 구현 가능한 실제 아키텍처를 제시합니다. 각 섹션의 코드 예시와 패턴을 참고하여 실제 라이브러리를 구현할 수 있습니다.
